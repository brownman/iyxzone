class MiniBlog < ActiveRecord::Base

  serialize :nodes, Array

  serialize :forwarder_ids, Array

  belongs_to :poster, :polymorphic => true

  belongs_to :root, :class_name => 'MiniBlog'

  belongs_to :parent, :class_name => 'MiniBlog'

  has_many :children, :class_name => 'MiniBlog', :foreign_key => 'parent_id'

  named_scope :hot, :conditions => {:deleted => false}, :order => "forwards_count DESC, created_at DESC"
  
  named_scope :sexy, :conditions => {:deleted => false}, :order => "comments_count DESC, created at DESC"

  named_scope :category, lambda {|type|
    if type == 'all'
      {}
    elsif type == 'original'
      {:conditions => {:root_id => nil, :parent_id => nil}}
    elsif type == 'text'
      {:conditions => {:videos_count => 0, :images_count => 0}}
    elsif type == 'video'
      {:conditions => "videos_count != 0"}
    elsif type == 'image'
      {:conditions => "images_count != 0"}
    end
  }

  acts_as_commentable :recipient_required => false, :order => 'created_at ASC'
 
  def poster= poster
    unless poster.blank?
      self.poster_id = poster.id
      self.poster_type = poster.class.name
    end
  end

  def text_type?
    images_count == 0 and videos_count == 0
  end

  # 有可能，这条围脖同时是image type和video type
  def image_type?
    images_count != 0
  end

  def video_type?
    videos_count != 0
  end

  def original?
    root_id.nil? and parent_id.nil?
  end

  def forward user, content
    MiniBlog.create :poster => user, :parent_id => id, :root_id => (original? ? id : root_id), :content => content
  end

  def forwarders
    # TODO: 为啥这样的顺序就不对了
    #User.find(forwarder_ids || [])
    (forwarder_ids || []).map {|id| User.find_by_id(id)}
  end 

  has_one :mini_image

  def mini_topics
    nodes.select{|n| n[:type] == 'topic'}.map{|n| MiniLink.find_by_name n[:name]}
  end

  def mini_videos
    mini_links.select {|l| l.is_video?}
  end

  def mini_links
    nodes.select{|n| n[:type] == 'link'}.map{|n| MiniLink.find_by_proxy_url n[:proxy_url]}
  end

  def relative_users
    nodes.select{|n| n[:type] == 'ref'}.map{|n| MiniLink.find_by_login n[:login]}
  end

  def mini_image_id= image_id
    @mini_image_id = image_id.blank? ? nil : image_id.to_i
  end

  after_create :update_mini_image

  before_create :parse_content

  validates_size_of :content, :within => 1..140

  def seudo_destroy
    update_attributes(:deleted => true)
  end

protected

  def update_mini_image
    unless @mini_image_id.blank?
      MiniImage.update_all("mini_blog_id = #{id}", {:id => @mini_image_id})
      raw_increment :images_count
      @mini_image_id = nil
    end
  end

  def parse_content
    nodes = []
    MiniBlogParser.parse(content).each do |node|
      case node[:type]
      when 'text'
        nodes << {:type => 'text', :val => node[:val]}
      when 'topic'
        MiniTopic.find_or_create :name => node[:val]
        nodes << {:type => 'topic', :name => node[:val]}
      when 'link'
        if node[:val] =~ MiniLink::UrlReg
          mini_link = MiniLink.find_by_proxy_url node[:val]
        else
          mini_link = MiniLink.find_or_create :url => node[:val]
        end
        increment :videos_count if !mini_link.blank? and mini_link.is_video?
        nodes << {:type => 'link', :proxy_url => mini_link.nil? ? node[:val] : mini_link.proxy_url}
      when 'ref'
        nodes << {:type => 'ref', :login => node[:val]}
      end
    end
    self.nodes = nodes 
  end

end
